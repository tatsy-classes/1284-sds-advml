NumPyの基本
===

NumPyの解説に入る前に、以下で用いるIPython環境について簡単に触れておく。IPythonとはInteractive Pythonの略でWindowsならコマンドプロンプトかPowerShell, Mac/Linuxならターミナルを開いて、

```shell
ipython
```

と打ち込むと、

```python
In [1]: 
```

のように表示されて、Pythonのコマンドを打ち込めるようになる。試しに電卓として以下のような計算を試してみよう。

```python
In [1]: 1 + 2  # Enterを押す(以下では省略する)
Out[1]: 3
```

上記の通り`1 + 2`の計算結果が正しく表示されることが分かる。また、変数に対する代入などといったPythonで普通に行える操作は使い勝手の善し悪しはあるももの、全て使用可能である。

```python
In [2]: a = 1

In [3]: b = 2

In [4]: a + b
Out[4]: 3
```

なお、以下では特別な理由がない限り`In [1]:`や`Out [1]`のような表記は省略するので注意すること。

## Pythonの配列とNumPyの配列

NumPyは一口に言えば、多次元の配列で表わされるデータ (例えば音声なら1次元の配列、画像なら2次元の配列)を様々な線形代数的な演算によって扱いやすくするためのライブラリといえる。まずは、Pythonの配列とNumPyの配列の違いについて見てみたい。

Pythonで配列を作成するには`[ ]`で数字をコンマ区切りにすれば良く、

```python
numbers = [1, 2, 3]
```

と書く。この時、aの各要素を2倍にしたいとすると、直感的には

```python
numbers * 2
```

とすれば良さそうだが、これは

```python
In [1]: numbers = [1, 2, 3]

In [2]: numbers * 2
Out[2]: [1, 2, 3, 1, 2, 3]
```

のように配列が2回繰り返されたものとなってしまう。Pythonの配列でこれを実現するには*リスト内包表記*と呼ばれる記法を使って

```python
In [2]: [x * 2 for x in numbers]
Out[2]: [2, 4, 6]
```

と書く必要がある。もちろん、これでも必要十分ではあるのだが、気持ちとしては、より直感的な記述で書きたいと思うのが人情という物だ。そこでNumPyの登場である。

NumPyはPythonの配列を引数にとる関数`numpy.array`を用いて、

```python
import numpy as np
numbers = np.array([1, 2, 3])
``` 

と書くことで作成できる。NumPyの配列であれば、下記のように要素を2倍にする計算を、より直感的に行うことができる。

```python
In [1]: import numpy as np

In [2]: numbers = np.array([1, 2, 3])

In [3]: numbers * 2
Out[3]: array([2, 4, 6])
```

### 多次元配列を作る

Pythonの配列で多次元配列を作るには、

```python
numbers = [[1, 2], [3, 4]]
```

のように`[ ]`を二重にすれば良かった。また、全ての要素が1の10x10の二次元配列を作りたい場合には、リスト内包表記を用いて

```python
ones = [[1] * 10 for _ in range(10)]
```

のように書く必要がある。NumPyで同様の配列を作る場合、先ほど紹介した方法で`numpy.array`の引数にPythonの多次元配列を代入すれば良い。

```python
numbers = [[1, 2], [3, 4]]
numbers_np = np.array(numbers)
```

また、NumPyにはいくつかの特殊な配列を作る関数が用意されていて、全ての要素が0や全ての要素が1、または特定の要素を持つ配列は次のように作成できる。

```python
zeros = np.zeros((10, 10))   # 全ての要素が0の10x10の二次元配列
ones = np.ones((10, 10))     # 全ての要素が1の10x10の二次元配列
twos = np.full((10, 10), 2)  # 全ての要素が2の10x10の二次元配列
```

上記の関数を使う場合、関数の引数がPythonの配列ではなく、多次元配列の大きさを表すタプルになるので注意すること。

### 配列の情報

上記のNumPyの配列をIPython上で表示すると

```python
In [1]: numbers = np.array([1, 2, 3])

In [2]: numbers
Out[2]: array([1, 2, 3])
```

のように表示されるが、この実態は`int32`型すなわち32bit符号付き整数となっている。これを調べるには，配列の`dtype`フィールドにアクセスすれば良く

```python
In [3]: numbers.dtype
Out[3]: dtype('int32')
```

のような出力が得られる。

また、配列の大きさは`shape`フィールドに、何次元の多次元配列なのかは`ndim`フィールドにアクセスすることで調べることができる。

```python
In [1]: ones = np.ones((4, 5, 6))

In [2]: ones.shape
Out[2]: (4, 5, 6)

In [3]: ones.ndim
Out[3]: 3
```

また、始めから配列要素の型を指定して、

```python
numbers = np.array([1, 2, 3], dtype='float32')
```

のようにすることもできる。上記の例では、配列内の各要素が`float32`型、すなわち32bitの単精度浮動小数で表わされる。NumPyで使える配列の型には、この他にも`int8` / `uint8` (それぞれ8bit符号あり、符号なし整数)以下、`int16`、`int32`、`int64`が符号付き整数 (それぞれに符号なし整数である`uint..`が存在)の他、64bit倍精度浮動小数として`double`、また複素数を表わす`complex64` (実部と虚部がそれぞれ32bit単精度浮動小数)や`complex128` (実部と虚部がそれぞれ64bit浮動小数)などがある。

最初に異なる型で宣言した配列を途中から別の型に変更したい場合には`astype`メソッドを使って、

```
numbers = np.array([1, 2, 3])  # int32型
numbers = numbers.astype('float32')  # 型をfloat32に変更
```

のようにすることで実現できる。

---

#### 閑話休題: オブジェクト指向型言語の用語

Pythonはプログラミング言語の中ではオブジェクト指向型の言語に分類される (他には手続き型や関数型などがある)。オブジェクト指向型言語では、実世界のモノをプログラムにより表現するための仕組みとしてモノ(= オブジェクト)を「クラス」という概念で表わす。ここでは、詳しい明言を避けるが、Pythonのクラスとは以下のようなものだ。

```python
class Human(object):
  def __init__(self, name, age):
    self.name = name
    self.age = age

  def intro(self):
    print('Hi, my name is %s. I\'m %d years old.' % (self.name, self.age))
```

このようなクラスにおいて、クラスが保持する変数 (= `self.name`や`self.age`)のことを**パラメータ**や**フィールド**と呼び、クラスが備える関数(= `intro`)のことを**メソッド**と呼ぶ。

また、上記のクラスを用いて、実際の`Human`を作ること、すなわち

```python
taro = Human('Taro', 22)
```

という処理を**インスタンス化**と呼ぶ。これらの用語はPythonに限らず、オブジェクト指向型言語の基本用語なので覚えておくこと。

---

## NumPyを用いた線形代数

### スカラに対する演算

ベクトルや行列に対して、スカラを四則演算すると、要素ごとに同じ計算が行われる。例えば、

```python
a = np.array([1, 2])
print(a + 1)  # array([2, 3])
```

の例では、aの各要素に1が足し算されていることが分かる。これは、他の四則演算に対しても同様である。

### 要素ごとの四則演算

同じ要素数を持つベクトル同士や行列同士を四則演算すると、要素ごとの演算が行われる。例えば、

```python
a = np.array([1, 2])
b = np.array([3, 4])
print(a + b)  # array([4, 6])
```

の例では、aとbの各要素に対して、和が取られていることが分かる。これは、他の四則演算に対しても同様である。

### 各要素への関数適用

NumPyには`numpy.exp`などのように、ベクトル・行列の各要素に対して、特定のスカラに対する演算を行う関数が用意されている。一例として、`numpy.sin`、`numpy.cos`、`numpy.exp`、`numpy.log`などがあり、高校レベルで思いつくものであれば大抵は用意されている。

### ベクトルの内積

内積の計算には二つのベクトルに対して`numpy.dot`を用いれば良い。

```python
a = np.array([1, 2])
b = np.array([3, 4])
print(np.dot(a, b))  # 11
```

また、`numpy.dot`と同じ効果を現す演算子として`@`が用意されており、上と同様のコードは`@`を使って以下のように書ける。

```python
print(a @ b)  # 11
```

### ベクトルの外積

外積の計算には二つのベクトルに対して`numpy.cross`を用いれば良い。

```python
a = np.array([1, 2, 3])
b = np.array([4, 5, 6])
print(np.cross(a, b))  # array([-3, 6, -3])
```

なお、この`numpy.cross`は二次元ベクトルに対しても計算が可能で、その場合は二次元ベクトルを並べて作られる2x2行列の行列式が計算される。

```python
a = np.array([1, 2])
b = np.array([3, 4])
print(np.cross(a, b))  # -2
```

この計算は二次元平面においてa → bというベクトルの移動が時計回りの回転(負の値になる)なのか、反時計回りの回転(正の値になる)なのかを調べる時などに役に立つ。

### 逆行列・疑似逆行列

とある行列が正則行列 (逆行列を持つ = 行列式が0でない)ときには`numpy.linalg.inv`を用いて逆行列が計算できる。

```python
A = np.array([[1, 2], [3, 4]], dtype='double')
invA = np.linalg.inv(A)
print(invA)
# array([[-2. ,  1. ],
#        [ 1.5, -0.5]])
```

なお、その行列が正則行列かどうかを調べるには、行列のランクや行列式が0でないかを調べれば良いだろう。

```python
# 行列のランク
np.linalg.matrix_rank(A)  # 2
# 行列式
np.linalg.det(A)  # -2.0000
```

では、次に、正則でない行列 (= 特異行列という)の場合に逆行列を求めようとするとどうなるかを見てみる。

```python
A = np.array([[1, 2], [2, 4]], dtype='double')
np.linalg.inv(A)
```

上記の例では、おそらくエラーメッセージが数行表示されて、最後の行に"**LinAlgError: Singular matrix**"と表示されるはずだ。実際、上記の行列のランクは1で行列式は0.0になるので、各自で調べて見てほしい。

さて、このようは特異行列に対して、逆行列を求めるにはどうすれば良いのだろうか？特異行列に対して、逆行列を求めたい場面というのは実用上はそれなりに多く、その一番身近な例が、以下のような最小二乗問題を解きたい場合だろう。

$$
\min_{\mathbf{x}} \frac{1}{2} \| \mathbf{Ax} - \mathbf{b} \|^2
$$

この場合、$\mathbf{x}$について被最小化関数を微分したものがゼロベクトルになる箇所を探せば、それが求める$\mathbf{x}$だが、この際、被最小化関数の$\mathbf{x}$についての微分によって得られる

$$
\mathbf{A}^\top \mathbf{Ax} = \mathbf{A}^\top \mathbf{b}
$$

という方程式において$\mathbf{A}^\top \mathbf{A}$が特異行列になることは実問題においては頻繁に起こる問題である。

このような場合、上記の最小化問題の解は、特異行列に対して逆行列と似た性質を持つ疑似逆行列 (正しくはMoore-Penroseの疑似逆行列と呼ぶ)を右辺に乗ずることで求められる。

すなわち、疑似逆行列を$(\mathbf{A}^\top \mathbf{A})^\dagger$のように表わす時、最小化を実現する$\mathbf{x}$は次の式のように定まる。

$$
\mathbf{x} = (\mathbf{A}^\top \mathbf{A})^\dagger (\mathbf{A}^\top \mathbf{b})
$$

では、疑似逆行列とは、一体どういう性質を持った行列なのだろうか？これを説明するには特異値分解について説明をする必要があるため、詳しくは触れないが、ぜひNumPyで疑似逆行列を求める`numpy.linalg.pinv`を用いて、以下の計算を試してみてほしい。

```python
A = np.array([[1, 2], [2, 4]], dtype='double')
pinvA = np.linalg.pinv(A)
print(pinvA @ A)
print(A @ pinvA @ A)
```

### 行列の固有値・固有ベクトル

---

#### 閑話休題: 数値誤差

上記の例ではNumPyの関数を用いて行列式や逆行列を求める方法について紹介してきた。

---

## 練習課題

1. 今回の講義で紹介したサンプルコードを踏まえて、正則行列に対する逆行列と、特異行列に対する疑似逆行列の違いと共通点について述べよ。
1. NumPyには多項方程式を解くための関数として`numpy.roots`という関数が用意されている ([参考](https://numpy.org/doc/stable/reference/generated/numpy.roots.html)、特性方程式の係数は手計算で求めること)。この関数を用いて、以下の行列について、特性方程式を解くことで得られる固有値と、`numpy.linalg.eig`を解くことで得られる固有値が一致することを調べよ。
$$
\mathbf{A} = \begin{pmatrix} 1 & 2 & 3 \\ 2 & 2 & 3 \\ 3 & 3 & 3 \end{pmatrix}
$$



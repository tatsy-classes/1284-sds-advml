NumPyの基本
===

NumPyの解説に入る前に、以下で用いるIPython環境について簡単に触れておく。IPythonとはInteractive Pythonの略でWindowsならコマンドプロンプトかPowerShell, Mac/Linuxならターミナルを開いて、

```shell
ipython
```

と打ち込むと、

```python
In [1]: 
```

のように表示されて、Pythonのコマンドを打ち込めるようになる。試しに電卓として以下のような計算を試してみよう。

```python
In [1]: 1 + 2  # Enterを押す(以下では省略する)
Out[1]: 3
```

上記の通り`1 + 2`の計算結果が正しく表示されることが分かる。また、変数に対する代入などといったPythonで普通に行える操作は使い勝手の善し悪しはあるももの、全て使用可能である。

```python
In [2]: a = 1

In [3]: b = 2

In [4]: a + b
Out[4]: 3
```

なお、以下では特別な理由がない限り`In [1]:`や`Out [1]`のような表記は省略するので注意すること。

## Pythonの配列とNumPyの配列

NumPyは一口に言えば、多次元の配列で表わされるデータ (例えば音声なら1次元の配列、画像なら2次元の配列)を様々な線形代数的な演算によって扱いやすくするためのライブラリといえる。まずは、Pythonの配列とNumPyの配列の違いについて見てみたい。

Pythonで配列を作成するには`[ ]`で数字をコンマ区切りにすれば良く、

```python
numbers = [1, 2, 3]
```

と書く。この時、aの各要素を2倍にしたいとすると、直感的には

```python
numbers * 2
```

とすれば良さそうだが、これは

```python
In [1]: numbers = [1, 2, 3]

In [2]: numbers * 2
Out[2]: [1, 2, 3, 1, 2, 3]
```

のように配列が2回繰り返されたものとなってしまう。Pythonの配列でこれを実現するには*リスト内包表記*と呼ばれる記法を使って

```python
In [2]: [x * 2 for x in numbers]
Out[2]: [2, 4, 6]
```

と書く必要がある。もちろん、これでも必要十分ではあるのだが、気持ちとしては、より直感的な記述で書きたいと思うのが人情という物だ。そこでNumPyの登場である。

NumPyはPythonの配列を引数にとる関数`numpy.array`を用いて、

```python
import numpy as np
numbers = np.array([1, 2, 3])
``` 

と書くことで作成できる。NumPyの配列であれば、下記のように要素を2倍にする計算を、より直感的に行うことができる。

```python
In [1]: import numpy as np

In [2]: numbers = np.array([1, 2, 3])

In [3]: numbers * 2
Out[3]: array([2, 4, 6])
```

### 多次元配列を作る

Pythonの配列で多次元配列を作るには、

```python
numbers = [[1, 2], [3, 4]]
```

のように`[ ]`を二重にすれば良かった。また、全ての要素が1の10x10の二次元配列を作りたい場合には、リスト内包表記を用いて

```python
ones = [[1] * 10 for _ in range(10)]
```

のように書く必要がある。NumPyで同様の配列を作る場合、先ほど紹介した方法で`numpy.array`の引数にPythonの多次元配列を代入すれば良い。

```python
numbers = [[1, 2], [3, 4]]
numbers_np = np.array(numbers)
```

また、NumPyにはいくつかの特殊な配列を作る関数が用意されていて、全ての要素が0や全ての要素が1、または特定の要素を持つ配列は次のように作成できる。

```python
zeros = np.zeros((10, 10))   # 全ての要素が0の10x10の二次元配列
ones = np.ones((10, 10))     # 全ての要素が1の10x10の二次元配列
twos = np.full((10, 10), 2)  # 全ての要素が2の10x10の二次元配列
```

上記の関数を使う場合、関数の引数がPythonの配列ではなく、多次元配列の大きさを表すタプルになるので注意すること。

### 配列の情報

上記のNumPyの配列をIPython上で表示すると

```python
In [1]: numbers = np.array([1, 2, 3])

In [2]: numbers
Out[2]: array([1, 2, 3])
```

のように表示されるが、この実態は`int32`型すなわち32bit符号付き整数となっている。これを調べるには，配列の`dtype`フィールドにアクセスすれば良く

```python
In [3]: numbers.dtype
Out[3]: dtype('int32')
```

のような出力が得られる。

また、配列の大きさは`shape`フィールドに、何次元の多次元配列なのかは`ndim`フィールドにアクセスすることで調べることができる。

```python
In [1]: ones = np.ones((4, 5, 6))

In [2]: ones.shape
Out[2]: (4, 5, 6)

In [3]: ones.ndim
Out[3]: 3
```

また、始めから配列要素の型を指定して、

```python
numbers = np.array([1, 2, 3], dtype='float32')
```

のようにすることもできる。上記の例では、配列内の各要素が`float32`型、すなわち32bitの単精度浮動小数で表わされる。NumPyで使える配列の型には、この他にも`int8` / `uint8` (それぞれ8bit符号あり、符号なし整数)以下、`int16`、`int32`、`int64`が符号付き整数 (それぞれに符号なし整数である`uint..`が存在)の他、64bit倍精度浮動小数として`double`、また複素数を表わす`complex64` (実部と虚部がそれぞれ32bit単精度浮動小数)や`complex128` (実部と虚部がそれぞれ64bit浮動小数)などがある。

最初に異なる型で宣言した配列を途中から別の型に変更したい場合には`astype`メソッドを使って、

```
numbers = np.array([1, 2, 3])  # int32型
numbers = numbers.astype('float32')  # 型をfloat32に変更
```

のようにすることで実現できる。

---

#### 閑話休題: オブジェクト指向型言語の用語

Pythonはプログラミング言語の中ではオブジェクト指向型の言語に分類される (他には手続き型や関数型などがある)。オブジェクト指向型言語では、実世界のモノをプログラムにより表現するための仕組みとしてモノ(= オブジェクト)を「クラス」という概念で表わす。ここでは、詳しい明言を避けるが、Pythonのクラスとは以下のようなものだ。

```python
class Human(object):
  def __init__(self, name, age):
    self.name = name
    self.age = age

  def intro(self):
    print('Hi, my name is %s. I\'m %d years old.' % (self.name, self.age))
```

このようなクラスにおいて、クラスが保持する変数 (= `self.name`や`self.age`)のことを**パラメータ**や**フィールド**と呼び、クラスが備える関数(= `intro`)のことを**メソッド**と呼ぶ。

また、上記のクラスを用いて、実際の`Human`を作ること、すなわち

```python
taro = Human('Taro', 22)
```

という処理を**インスタンス化**と呼ぶ。これらの用語はPythonに限らず、オブジェクト指向型言語の基本用語なので覚えておくこと。

---

## NumPyを用いた線形代数

